// Generated by `wit-bindgen` 0.24.0. DO NOT EDIT!
// Options used:
#[doc(hidden)]
#[allow(non_snake_case)]
pub unsafe fn _export_register_routes_cabi<T: Guest>() {
    #[cfg(target_arch = "wasm32")]
    _rt::run_ctors_once();
    T::register_routes();
}
#[doc(hidden)]
#[allow(non_snake_case)]
pub unsafe fn _export_load_from_ledger_cabi<T: Guest>(arg0: *mut u8, arg1: usize) {
    #[cfg(target_arch = "wasm32")]
    _rt::run_ctors_once();
    let len0 = arg1;
    let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
    T::load_from_ledger(_rt::string_lift(bytes0));
}
#[doc(hidden)]
#[allow(non_snake_case)]
pub unsafe fn _export_insert_in_ledger_cabi<T: Guest>(arg0: *mut u8, arg1: usize) {
    #[cfg(target_arch = "wasm32")]
    _rt::run_ctors_once();
    let len0 = arg1;
    let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
    T::insert_in_ledger(_rt::string_lift(bytes0));
}
#[doc(hidden)]
#[allow(non_snake_case)]
pub unsafe fn _export_ping_cabi<T: Guest>() {
    #[cfg(target_arch = "wasm32")]
    _rt::run_ctors_once();
    T::ping();
}
pub trait Guest {
    fn register_routes();
    fn load_from_ledger(cmd: _rt::String);
    fn insert_in_ledger(cmd: _rt::String);
    fn ping();
}
#[doc(hidden)]

macro_rules! __export_world_example_cabi{
  ($ty:ident with_types_in $($path_to_types:tt)*) => (const _: () = {

    #[export_name = "register-routes"]
    unsafe extern "C" fn export_register_routes() {
      $($path_to_types)*::_export_register_routes_cabi::<$ty>()
    }
    #[export_name = "load-from-ledger"]
    unsafe extern "C" fn export_load_from_ledger(arg0: *mut u8,arg1: usize,) {
      $($path_to_types)*::_export_load_from_ledger_cabi::<$ty>(arg0, arg1)
    }
    #[export_name = "insert-in-ledger"]
    unsafe extern "C" fn export_insert_in_ledger(arg0: *mut u8,arg1: usize,) {
      $($path_to_types)*::_export_insert_in_ledger_cabi::<$ty>(arg0, arg1)
    }
    #[export_name = "ping"]
    unsafe extern "C" fn export_ping() {
      $($path_to_types)*::_export_ping_cabi::<$ty>()
    }
  };);
}
#[doc(hidden)]
pub(crate) use __export_world_example_cabi;
#[allow(dead_code)]
pub mod klave {
    #[allow(dead_code)]
    pub mod sdk {
        #[allow(dead_code, clippy::all)]
        pub mod sdk {
            #[used]
            #[doc(hidden)]
            #[cfg(target_arch = "wasm32")]
            static __FORCE_SECTION_REF: fn() =
                super::super::super::__link_custom_section_describing_imports;
            use super::super::super::_rt;
            #[allow(unused_unsafe, clippy::all)]
            /// for now no types : keep same interface as pure host-provided native calls
            /// should only be called by register-routes
            pub fn add_user_query(query_name: &str) {
                unsafe {
                    let vec0 = query_name;
                    let ptr0 = vec0.as_ptr().cast::<u8>();
                    let len0 = vec0.len();

                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "klave:sdk/sdk")]
                    extern "C" {
                        #[link_name = "add-user-query"]
                        fn wit_import(_: *mut u8, _: usize);
                    }

                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import(_: *mut u8, _: usize) {
                        unreachable!()
                    }
                    wit_import(ptr0.cast_mut(), len0);
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            pub fn add_user_transaction(transaction_name: &str) {
                unsafe {
                    let vec0 = transaction_name;
                    let ptr0 = vec0.as_ptr().cast::<u8>();
                    let len0 = vec0.len();

                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "klave:sdk/sdk")]
                    extern "C" {
                        #[link_name = "add-user-transaction"]
                        fn wit_import(_: *mut u8, _: usize);
                    }

                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import(_: *mut u8, _: usize) {
                        unreachable!()
                    }
                    wit_import(ptr0.cast_mut(), len0);
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// normal sdk calls
            pub fn notify(msg: &str) -> i32 {
                unsafe {
                    let vec0 = msg;
                    let ptr0 = vec0.as_ptr().cast::<u8>();
                    let len0 = vec0.len();

                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "klave:sdk/sdk")]
                    extern "C" {
                        #[link_name = "notify"]
                        fn wit_import(_: *mut u8, _: usize) -> i32;
                    }

                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import(_: *mut u8, _: usize) -> i32 {
                        unreachable!()
                    }
                    let ret = wit_import(ptr0.cast_mut(), len0);
                    ret
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            pub fn notify_error(msg: &str) -> i32 {
                unsafe {
                    let vec0 = msg;
                    let ptr0 = vec0.as_ptr().cast::<u8>();
                    let len0 = vec0.len();

                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "klave:sdk/sdk")]
                    extern "C" {
                        #[link_name = "notify-error"]
                        fn wit_import(_: *mut u8, _: usize) -> i32;
                    }

                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import(_: *mut u8, _: usize) -> i32 {
                        unreachable!()
                    }
                    let ret = wit_import(ptr0.cast_mut(), len0);
                    ret
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            pub fn on_success_notify(msg: &str) -> i32 {
                unsafe {
                    let vec0 = msg;
                    let ptr0 = vec0.as_ptr().cast::<u8>();
                    let len0 = vec0.len();

                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "klave:sdk/sdk")]
                    extern "C" {
                        #[link_name = "on-success-notify"]
                        fn wit_import(_: *mut u8, _: usize) -> i32;
                    }

                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import(_: *mut u8, _: usize) -> i32 {
                        unreachable!()
                    }
                    let ret = wit_import(ptr0.cast_mut(), len0);
                    ret
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            pub fn query_context(param: &str) -> _rt::String {
                unsafe {
                    #[repr(align(4))]
                    struct RetArea([::core::mem::MaybeUninit<u8>; 8]);
                    let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 8]);
                    let vec0 = param;
                    let ptr0 = vec0.as_ptr().cast::<u8>();
                    let len0 = vec0.len();
                    let ptr1 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "klave:sdk/sdk")]
                    extern "C" {
                        #[link_name = "query-context"]
                        fn wit_import(_: *mut u8, _: usize, _: *mut u8);
                    }

                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import(_: *mut u8, _: usize, _: *mut u8) {
                        unreachable!()
                    }
                    wit_import(ptr0.cast_mut(), len0, ptr1);
                    let l2 = *ptr1.add(0).cast::<*mut u8>();
                    let l3 = *ptr1.add(4).cast::<usize>();
                    let len4 = l3;
                    let bytes4 = _rt::Vec::from_raw_parts(l2.cast(), len4, len4);
                    _rt::string_lift(bytes4)
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            pub fn read_ledger(table: &str, key: &[u8]) -> _rt::Vec<u8> {
                unsafe {
                    #[repr(align(4))]
                    struct RetArea([::core::mem::MaybeUninit<u8>; 8]);
                    let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 8]);
                    let vec0 = table;
                    let ptr0 = vec0.as_ptr().cast::<u8>();
                    let len0 = vec0.len();
                    let vec1 = key;
                    let ptr1 = vec1.as_ptr().cast::<u8>();
                    let len1 = vec1.len();
                    let ptr2 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "klave:sdk/sdk")]
                    extern "C" {
                        #[link_name = "read-ledger"]
                        fn wit_import(_: *mut u8, _: usize, _: *mut u8, _: usize, _: *mut u8);
                    }

                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import(_: *mut u8, _: usize, _: *mut u8, _: usize, _: *mut u8) {
                        unreachable!()
                    }
                    wit_import(ptr0.cast_mut(), len0, ptr1.cast_mut(), len1, ptr2);
                    let l3 = *ptr2.add(0).cast::<*mut u8>();
                    let l4 = *ptr2.add(4).cast::<usize>();
                    let len5 = l4;
                    _rt::Vec::from_raw_parts(l3.cast(), len5, len5)
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            pub fn write_ledger(table: &str, key: &[u8], value: &[u8]) -> i32 {
                unsafe {
                    let vec0 = table;
                    let ptr0 = vec0.as_ptr().cast::<u8>();
                    let len0 = vec0.len();
                    let vec1 = key;
                    let ptr1 = vec1.as_ptr().cast::<u8>();
                    let len1 = vec1.len();
                    let vec2 = value;
                    let ptr2 = vec2.as_ptr().cast::<u8>();
                    let len2 = vec2.len();

                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "klave:sdk/sdk")]
                    extern "C" {
                        #[link_name = "write-ledger"]
                        fn wit_import(
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                            _: usize,
                        ) -> i32;
                    }

                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import(
                        _: *mut u8,
                        _: usize,
                        _: *mut u8,
                        _: usize,
                        _: *mut u8,
                        _: usize,
                    ) -> i32 {
                        unreachable!()
                    }
                    let ret = wit_import(
                        ptr0.cast_mut(),
                        len0,
                        ptr1.cast_mut(),
                        len1,
                        ptr2.cast_mut(),
                        len2,
                    );
                    ret
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            pub fn remove_from_ledger(table: &str, key: &[u8]) -> i32 {
                unsafe {
                    let vec0 = table;
                    let ptr0 = vec0.as_ptr().cast::<u8>();
                    let len0 = vec0.len();
                    let vec1 = key;
                    let ptr1 = vec1.as_ptr().cast::<u8>();
                    let len1 = vec1.len();

                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "klave:sdk/sdk")]
                    extern "C" {
                        #[link_name = "remove-from-ledger"]
                        fn wit_import(_: *mut u8, _: usize, _: *mut u8, _: usize) -> i32;
                    }

                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import(_: *mut u8, _: usize, _: *mut u8, _: usize) -> i32 {
                        unreachable!()
                    }
                    let ret = wit_import(ptr0.cast_mut(), len0, ptr1.cast_mut(), len1);
                    ret
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            pub fn load_lightgbm_model(name: &str, model: &str) -> i32 {
                unsafe {
                    let vec0 = name;
                    let ptr0 = vec0.as_ptr().cast::<u8>();
                    let len0 = vec0.len();
                    let vec1 = model;
                    let ptr1 = vec1.as_ptr().cast::<u8>();
                    let len1 = vec1.len();

                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "klave:sdk/sdk")]
                    extern "C" {
                        #[link_name = "load-lightgbm-model"]
                        fn wit_import(_: *mut u8, _: usize, _: *mut u8, _: usize) -> i32;
                    }

                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import(_: *mut u8, _: usize, _: *mut u8, _: usize) -> i32 {
                        unreachable!()
                    }
                    let ret = wit_import(ptr0.cast_mut(), len0, ptr1.cast_mut(), len1);
                    ret
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            pub fn unload_lightgbm_model(name: &str) -> i32 {
                unsafe {
                    let vec0 = name;
                    let ptr0 = vec0.as_ptr().cast::<u8>();
                    let len0 = vec0.len();

                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "klave:sdk/sdk")]
                    extern "C" {
                        #[link_name = "unload-lightgbm-model"]
                        fn wit_import(_: *mut u8, _: usize) -> i32;
                    }

                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import(_: *mut u8, _: usize) -> i32 {
                        unreachable!()
                    }
                    let ret = wit_import(ptr0.cast_mut(), len0);
                    ret
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            pub fn infer_from_lightgbm_model(name: &str, data: &[u8], len: i32) -> _rt::Vec<u8> {
                unsafe {
                    #[repr(align(4))]
                    struct RetArea([::core::mem::MaybeUninit<u8>; 8]);
                    let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 8]);
                    let vec0 = name;
                    let ptr0 = vec0.as_ptr().cast::<u8>();
                    let len0 = vec0.len();
                    let vec1 = data;
                    let ptr1 = vec1.as_ptr().cast::<u8>();
                    let len1 = vec1.len();
                    let ptr2 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "klave:sdk/sdk")]
                    extern "C" {
                        #[link_name = "infer-from-lightgbm-model"]
                        fn wit_import(
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                            _: usize,
                            _: i32,
                            _: *mut u8,
                        );
                    }

                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import(_: *mut u8, _: usize, _: *mut u8, _: usize, _: i32, _: *mut u8) {
                        unreachable!()
                    }
                    wit_import(
                        ptr0.cast_mut(),
                        len0,
                        ptr1.cast_mut(),
                        len1,
                        _rt::as_i32(&len),
                        ptr2,
                    );
                    let l3 = *ptr2.add(0).cast::<*mut u8>();
                    let l4 = *ptr2.add(4).cast::<usize>();
                    let len5 = l4;
                    _rt::Vec::from_raw_parts(l3.cast(), len5, len5)
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            pub fn key_exists(key_name: &str) -> i32 {
                unsafe {
                    let vec0 = key_name;
                    let ptr0 = vec0.as_ptr().cast::<u8>();
                    let len0 = vec0.len();

                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "klave:sdk/sdk")]
                    extern "C" {
                        #[link_name = "key-exists"]
                        fn wit_import(_: *mut u8, _: usize) -> i32;
                    }

                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import(_: *mut u8, _: usize) -> i32 {
                        unreachable!()
                    }
                    let ret = wit_import(ptr0.cast_mut(), len0);
                    ret
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            pub fn generate_encryption_key(key_name: &str) -> i32 {
                unsafe {
                    let vec0 = key_name;
                    let ptr0 = vec0.as_ptr().cast::<u8>();
                    let len0 = vec0.len();

                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "klave:sdk/sdk")]
                    extern "C" {
                        #[link_name = "generate-encryption-key"]
                        fn wit_import(_: *mut u8, _: usize) -> i32;
                    }

                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import(_: *mut u8, _: usize) -> i32 {
                        unreachable!()
                    }
                    let ret = wit_import(ptr0.cast_mut(), len0);
                    ret
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            pub fn encrypt(key_name: &str, plain_txt: &[u8]) -> _rt::Vec<u8> {
                unsafe {
                    #[repr(align(4))]
                    struct RetArea([::core::mem::MaybeUninit<u8>; 8]);
                    let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 8]);
                    let vec0 = key_name;
                    let ptr0 = vec0.as_ptr().cast::<u8>();
                    let len0 = vec0.len();
                    let vec1 = plain_txt;
                    let ptr1 = vec1.as_ptr().cast::<u8>();
                    let len1 = vec1.len();
                    let ptr2 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "klave:sdk/sdk")]
                    extern "C" {
                        #[link_name = "encrypt"]
                        fn wit_import(_: *mut u8, _: usize, _: *mut u8, _: usize, _: *mut u8);
                    }

                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import(_: *mut u8, _: usize, _: *mut u8, _: usize, _: *mut u8) {
                        unreachable!()
                    }
                    wit_import(ptr0.cast_mut(), len0, ptr1.cast_mut(), len1, ptr2);
                    let l3 = *ptr2.add(0).cast::<*mut u8>();
                    let l4 = *ptr2.add(4).cast::<usize>();
                    let len5 = l4;
                    _rt::Vec::from_raw_parts(l3.cast(), len5, len5)
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            pub fn decrypt(key_name: &str, cipher_txt: &[u8]) -> _rt::Vec<u8> {
                unsafe {
                    #[repr(align(4))]
                    struct RetArea([::core::mem::MaybeUninit<u8>; 8]);
                    let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 8]);
                    let vec0 = key_name;
                    let ptr0 = vec0.as_ptr().cast::<u8>();
                    let len0 = vec0.len();
                    let vec1 = cipher_txt;
                    let ptr1 = vec1.as_ptr().cast::<u8>();
                    let len1 = vec1.len();
                    let ptr2 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "klave:sdk/sdk")]
                    extern "C" {
                        #[link_name = "decrypt"]
                        fn wit_import(_: *mut u8, _: usize, _: *mut u8, _: usize, _: *mut u8);
                    }

                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import(_: *mut u8, _: usize, _: *mut u8, _: usize, _: *mut u8) {
                        unreachable!()
                    }
                    wit_import(ptr0.cast_mut(), len0, ptr1.cast_mut(), len1, ptr2);
                    let l3 = *ptr2.add(0).cast::<*mut u8>();
                    let l4 = *ptr2.add(4).cast::<usize>();
                    let len5 = l4;
                    _rt::Vec::from_raw_parts(l3.cast(), len5, len5)
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            pub fn generate_signing_key(key_name: &str) -> i32 {
                unsafe {
                    let vec0 = key_name;
                    let ptr0 = vec0.as_ptr().cast::<u8>();
                    let len0 = vec0.len();

                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "klave:sdk/sdk")]
                    extern "C" {
                        #[link_name = "generate-signing-key"]
                        fn wit_import(_: *mut u8, _: usize) -> i32;
                    }

                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import(_: *mut u8, _: usize) -> i32 {
                        unreachable!()
                    }
                    let ret = wit_import(ptr0.cast_mut(), len0);
                    ret
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            pub fn get_public_key(key_name: &str) -> _rt::Vec<u8> {
                unsafe {
                    #[repr(align(4))]
                    struct RetArea([::core::mem::MaybeUninit<u8>; 8]);
                    let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 8]);
                    let vec0 = key_name;
                    let ptr0 = vec0.as_ptr().cast::<u8>();
                    let len0 = vec0.len();
                    let ptr1 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "klave:sdk/sdk")]
                    extern "C" {
                        #[link_name = "get-public-key"]
                        fn wit_import(_: *mut u8, _: usize, _: *mut u8);
                    }

                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import(_: *mut u8, _: usize, _: *mut u8) {
                        unreachable!()
                    }
                    wit_import(ptr0.cast_mut(), len0, ptr1);
                    let l2 = *ptr1.add(0).cast::<*mut u8>();
                    let l3 = *ptr1.add(4).cast::<usize>();
                    let len4 = l3;
                    _rt::Vec::from_raw_parts(l2.cast(), len4, len4)
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            pub fn sign(key_name: &str, txt: &[u8]) -> _rt::Vec<u8> {
                unsafe {
                    #[repr(align(4))]
                    struct RetArea([::core::mem::MaybeUninit<u8>; 8]);
                    let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 8]);
                    let vec0 = key_name;
                    let ptr0 = vec0.as_ptr().cast::<u8>();
                    let len0 = vec0.len();
                    let vec1 = txt;
                    let ptr1 = vec1.as_ptr().cast::<u8>();
                    let len1 = vec1.len();
                    let ptr2 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "klave:sdk/sdk")]
                    extern "C" {
                        #[link_name = "sign"]
                        fn wit_import(_: *mut u8, _: usize, _: *mut u8, _: usize, _: *mut u8);
                    }

                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import(_: *mut u8, _: usize, _: *mut u8, _: usize, _: *mut u8) {
                        unreachable!()
                    }
                    wit_import(ptr0.cast_mut(), len0, ptr1.cast_mut(), len1, ptr2);
                    let l3 = *ptr2.add(0).cast::<*mut u8>();
                    let l4 = *ptr2.add(4).cast::<usize>();
                    let len5 = l4;
                    _rt::Vec::from_raw_parts(l3.cast(), len5, len5)
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            pub fn verify(key_name: &str, txt: &[u8], signature: &[u8]) -> i32 {
                unsafe {
                    let vec0 = key_name;
                    let ptr0 = vec0.as_ptr().cast::<u8>();
                    let len0 = vec0.len();
                    let vec1 = txt;
                    let ptr1 = vec1.as_ptr().cast::<u8>();
                    let len1 = vec1.len();
                    let vec2 = signature;
                    let ptr2 = vec2.as_ptr().cast::<u8>();
                    let len2 = vec2.len();

                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "klave:sdk/sdk")]
                    extern "C" {
                        #[link_name = "verify"]
                        fn wit_import(
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                            _: usize,
                        ) -> i32;
                    }

                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import(
                        _: *mut u8,
                        _: usize,
                        _: *mut u8,
                        _: usize,
                        _: *mut u8,
                        _: usize,
                    ) -> i32 {
                        unreachable!()
                    }
                    let ret = wit_import(
                        ptr0.cast_mut(),
                        len0,
                        ptr1.cast_mut(),
                        len1,
                        ptr2.cast_mut(),
                        len2,
                    );
                    ret
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            pub fn digest(txt: &[u8]) -> _rt::Vec<u8> {
                unsafe {
                    #[repr(align(4))]
                    struct RetArea([::core::mem::MaybeUninit<u8>; 8]);
                    let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 8]);
                    let vec0 = txt;
                    let ptr0 = vec0.as_ptr().cast::<u8>();
                    let len0 = vec0.len();
                    let ptr1 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "klave:sdk/sdk")]
                    extern "C" {
                        #[link_name = "digest"]
                        fn wit_import(_: *mut u8, _: usize, _: *mut u8);
                    }

                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import(_: *mut u8, _: usize, _: *mut u8) {
                        unreachable!()
                    }
                    wit_import(ptr0.cast_mut(), len0, ptr1);
                    let l2 = *ptr1.add(0).cast::<*mut u8>();
                    let l3 = *ptr1.add(4).cast::<usize>();
                    let len4 = l3;
                    _rt::Vec::from_raw_parts(l2.cast(), len4, len4)
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            pub fn get_random_bytes(len: i32) -> _rt::Vec<u8> {
                unsafe {
                    #[repr(align(4))]
                    struct RetArea([::core::mem::MaybeUninit<u8>; 8]);
                    let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 8]);
                    let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "klave:sdk/sdk")]
                    extern "C" {
                        #[link_name = "get-random-bytes"]
                        fn wit_import(_: i32, _: *mut u8);
                    }

                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import(_: i32, _: *mut u8) {
                        unreachable!()
                    }
                    wit_import(_rt::as_i32(&len), ptr0);
                    let l1 = *ptr0.add(0).cast::<*mut u8>();
                    let l2 = *ptr0.add(4).cast::<usize>();
                    let len3 = l2;
                    _rt::Vec::from_raw_parts(l1.cast(), len3, len3)
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            pub fn https_query(request: &str) -> _rt::String {
                unsafe {
                    #[repr(align(4))]
                    struct RetArea([::core::mem::MaybeUninit<u8>; 8]);
                    let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 8]);
                    let vec0 = request;
                    let ptr0 = vec0.as_ptr().cast::<u8>();
                    let len0 = vec0.len();
                    let ptr1 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "klave:sdk/sdk")]
                    extern "C" {
                        #[link_name = "https-query"]
                        fn wit_import(_: *mut u8, _: usize, _: *mut u8);
                    }

                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import(_: *mut u8, _: usize, _: *mut u8) {
                        unreachable!()
                    }
                    wit_import(ptr0.cast_mut(), len0, ptr1);
                    let l2 = *ptr1.add(0).cast::<*mut u8>();
                    let l3 = *ptr1.add(4).cast::<usize>();
                    let len4 = l3;
                    let bytes4 = _rt::Vec::from_raw_parts(l2.cast(), len4, len4);
                    _rt::string_lift(bytes4)
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            pub fn start_recording() -> i32 {
                unsafe {
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "klave:sdk/sdk")]
                    extern "C" {
                        #[link_name = "start-recording"]
                        fn wit_import() -> i32;
                    }

                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import() -> i32 {
                        unreachable!()
                    }
                    let ret = wit_import();
                    ret
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            pub fn stop_recording() -> i32 {
                unsafe {
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "klave:sdk/sdk")]
                    extern "C" {
                        #[link_name = "stop-recording"]
                        fn wit_import() -> i32;
                    }

                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import() -> i32 {
                        unreachable!()
                    }
                    let ret = wit_import();
                    ret
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            pub fn cancel_transaction() -> i32 {
                unsafe {
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "klave:sdk/sdk")]
                    extern "C" {
                        #[link_name = "cancel-transaction"]
                        fn wit_import() -> i32;
                    }

                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import() -> i32 {
                        unreachable!()
                    }
                    let ret = wit_import();
                    ret
                }
            }
        }
    }
}
mod _rt {
    pub use alloc_crate::string::String;
    pub use alloc_crate::vec::Vec;
    pub unsafe fn string_lift(bytes: Vec<u8>) -> String {
        if cfg!(debug_assertions) {
            String::from_utf8(bytes).unwrap()
        } else {
            String::from_utf8_unchecked(bytes)
        }
    }

    pub fn as_i32<T: AsI32>(t: T) -> i32 {
        t.as_i32()
    }

    pub trait AsI32 {
        fn as_i32(self) -> i32;
    }

    impl<'a, T: Copy + AsI32> AsI32 for &'a T {
        fn as_i32(self) -> i32 {
            (*self).as_i32()
        }
    }

    impl AsI32 for i32 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }

    impl AsI32 for u32 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }

    impl AsI32 for i16 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }

    impl AsI32 for u16 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }

    impl AsI32 for i8 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }

    impl AsI32 for u8 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }

    impl AsI32 for char {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }

    impl AsI32 for usize {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }

    #[cfg(target_arch = "wasm32")]
    pub fn run_ctors_once() {
        wit_bindgen_rt::run_ctors_once();
    }
    extern crate alloc as alloc_crate;
}

/// Generates `#[no_mangle]` functions to export the specified type as the
/// root implementation of all generated traits.
///
/// For more information see the documentation of `wit_bindgen::generate!`.
///
/// ```rust
/// # macro_rules! export{ ($($t:tt)*) => (); }
/// # trait Guest {}
/// struct MyType;
///
/// impl Guest for MyType {
///     // ...
/// }
///
/// export!(MyType);
/// ```
#[allow(unused_macros)]
#[doc(hidden)]

macro_rules! __export_example_impl {
  ($ty:ident) => (self::export!($ty with_types_in self););
  ($ty:ident with_types_in $($path_to_types_root:tt)*) => (
  $($path_to_types_root)*::__export_world_example_cabi!($ty with_types_in $($path_to_types_root)*);
  )
}
#[doc(inline)]
pub(crate) use __export_example_impl as export;

#[cfg(target_arch = "wasm32")]
#[link_section = "component-type:wit-bindgen:0.24.0:example:encoded world"]
#[doc(hidden)]
pub static __WIT_BINDGEN_COMPONENT_TYPE: [u8; 1111] = *b"\
\0asm\x0d\0\x01\0\0\x19\x16wit-component-encoding\x04\0\x07\xd9\x07\x01A\x02\x01\
A\x08\x01B/\x01@\x01\x0aquery-names\x01\0\x04\0\x0eadd-user-query\x01\0\x01@\x01\
\x10transaction-names\x01\0\x04\0\x14add-user-transaction\x01\x01\x01@\x01\x03ms\
gs\0z\x04\0\x06notify\x01\x02\x04\0\x0cnotify-error\x01\x02\x04\0\x11on-success-\
notify\x01\x02\x01@\x01\x05params\0s\x04\0\x0dquery-context\x01\x03\x01p}\x01@\x02\
\x05tables\x03key\x04\0\x04\x04\0\x0bread-ledger\x01\x05\x01@\x03\x05tables\x03k\
ey\x04\x05value\x04\0z\x04\0\x0cwrite-ledger\x01\x06\x01@\x02\x05tables\x03key\x04\
\0z\x04\0\x12remove-from-ledger\x01\x07\x01@\x02\x04names\x05models\0z\x04\0\x13\
load-lightgbm-model\x01\x08\x01@\x01\x04names\0z\x04\0\x15unload-lightgbm-model\x01\
\x09\x01@\x03\x04names\x04data\x04\x03lenz\0\x04\x04\0\x19infer-from-lightgbm-mo\
del\x01\x0a\x01@\x01\x08key-names\0z\x04\0\x0akey-exists\x01\x0b\x04\0\x17genera\
te-encryption-key\x01\x0b\x01@\x02\x08key-names\x09plain-txt\x04\0\x04\x04\0\x07\
encrypt\x01\x0c\x01@\x02\x08key-names\x0acipher-txt\x04\0\x04\x04\0\x07decrypt\x01\
\x0d\x04\0\x14generate-signing-key\x01\x0b\x01@\x01\x08key-names\0\x04\x04\0\x0e\
get-public-key\x01\x0e\x01@\x02\x08key-names\x03txt\x04\0\x04\x04\0\x04sign\x01\x0f\
\x01@\x03\x08key-names\x03txt\x04\x09signature\x04\0z\x04\0\x06verify\x01\x10\x01\
@\x01\x03txt\x04\0\x04\x04\0\x06digest\x01\x11\x01@\x01\x03lenz\0\x04\x04\0\x10g\
et-random-bytes\x01\x12\x01@\x01\x07requests\0s\x04\0\x0bhttps-query\x01\x13\x01\
@\0\0z\x04\0\x0fstart-recording\x01\x14\x04\0\x0estop-recording\x01\x14\x04\0\x12\
cancel-transaction\x01\x14\x03\x01\x0dklave:sdk/sdk\x05\0\x01@\0\x01\0\x04\0\x0f\
register-routes\x01\x01\x01@\x01\x03cmds\x01\0\x04\0\x10load-from-ledger\x01\x02\
\x04\0\x10insert-in-ledger\x01\x02\x04\0\x04ping\x01\x01\x04\x01\x1fcomponent:ru\
st-template/example\x04\0\x0b\x0d\x01\0\x07example\x03\0\0\0G\x09producers\x01\x0c\
processed-by\x02\x0dwit-component\x070.202.0\x10wit-bindgen-rust\x060.24.0";

#[inline(never)]
#[doc(hidden)]
#[cfg(target_arch = "wasm32")]
pub fn __link_custom_section_describing_imports() {
    wit_bindgen_rt::maybe_link_cabi_realloc();
}
